# **서버/컴퍼넌트/객체 간의 역할 분담/의존성/통신 방법 설계**

## 💻 Server
> 어떤 형태의 컴퓨터 이든 정보제공 역할을 하는 주체이면서 '서버' 컴퓨터라고 불릴 수 있다.  
> 서버라는 역할이 클라이언크가 언제 접속할지 모르고 얼마나 많은 사람들이 한꺼번에 접속할지 모르기 때문에 사양이 좋은 컴퓨터를 원하는 것.

## 🙋🏻‍♂️ Component
### **1. 컴퍼넌트는 독립적인 소프트웨어 모듈이다.**  
> 시스템을 유지보수 하는데 있어 교체 가능한 부품이다.  
 
### **2. 컴포넌트는 구현, 명세화, 패키지화, 그리고 배포 될 수 있어야 한다.**
> 소스코드가 아닌 실행코드 기반으로 재사용할 수 있도록 이미 구현이 완료 돼 있어야 한다.  
> 컴포넌트는 용도, 유형, 기술표준과 인터페이스등에 대한 정보들에 대해서 명세화 돼 있어야 한다.  
> 교체 가능한 컴퍼넌트를 개발하기 위해서는 표준을 준수하여 개발해야 한다.  
> 컴퍼넌트가 개발되어 배포될 때 관련 문서와 코드들이 독립적인 단위로 패키지화 돼 있어야 한다.  
> 컴퍼넌트는 독립적인 업무단위로 개발된 것이므로 사용자가 필요한 기능만을 패키지한 컴퍼넌트를 재사용할 수 있도록 배포 가능해야만 한다.

### **3. 컴퍼넌트는 하나 이상의 클래스로 구성될 수 있다.**
> 컴퍼넌트는 클래스랑은 다른 개념이며, 컴퍼넌트와 객체 또한 다른 개념이다.  
> 컴퍼넌트가 되기 위해서는 반드시 클래스나 객체로 만들어야 하는 것은 아니다.  

### **4. 컴퍼넌트는 인터페이스를 통해서만 접근할 수 있다.**
> 컴포넌트내의 정보는 외부로부터 모두 숨겨진다.(은닉)  
> 따라서 외부에서 접근할 수 있도록 컴퍼넌트가 제공하는 서비스를 정의한 인터페이스만을 제공하고 사용하기 위해서는 어떤 인터페이스를 사용해야 하는지 만을 알 수 있다.  
> 소프트웨어도 하드웨어처럼 조립 기반으로 갈 수 있게 되는 것이다.

## **🤦🏻 객체 간의 역할 분담**
### **1. 객체지향(Object Oriented)개념.**
> 실세계의 개체를 속성과 메서드가 결합한 형태의 객체로 표현하는 개념.

### **2. 객체지향 구성요소**
> Class: 같은 종류의 집단에 속하는 속성과 행위를 정의, 속성의 변수, 행위는 메서드, 기본적인 사용자 정의 데이터형.  
> Object: 객체의 행위는 클래스에 정의된 행위에 대한 정의를 공유함으로써 메모리를 경제적으로 사용.  
> Method: 클래스로부터 생성된 객체를 사용하는 방법, 전통적 시스템의 함수 또는 프로시저에 해당하는 기능.  
> Instance: 객체지향 기법에서 클래스에 속한 각각의 객체, 실제로 메모리상에 할당.  
> Property: 한 클래스 내에 객체들이 가지고 있는 데이터 값들을 단위별로 정의, 성질, 분류 ... 등에 대한 표현 값.

### **3. 객체지향 기법**
> 1. 캡슐화: 서로 관련성이 많은 데이터와 이와 관련된 함수들을 한 묶음으로 처리하는 기법, 결합도가 낮아지고 재사용이 용이, 변경 발생 시 오류의 파급 효과가 적음, 인터페이스가 단순화 됨.
> 2. 상속성: 상위 클래스의 속성과 메서드를 하위 클래스에서 재정의 없이 물려받아 사용하는 기법.
> 3. 다형성: 하나의 메시지에 대해 각 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력.
> 4. 정보은닉: 코드 내부 데이터와 메서드를 숨기고 공개 인터페이스를 통해서만 접근이 가능하도록 하는 코드 보안 기술.

### **4. 객체지향 설계 원칙(SOLID)**
> 1. 단일 책임의 원칙(Single Responsibility Principle): 하나의 클래스는 하나의 목적을 위해서 생성되며 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중 돼 있어야 한다는 원칙, 객체 지향 프로그래밍의 5원칙 중 4원칙의 "기초 원칙".
> 2. 개방 폐쇄 원칙(Open Close Principle): 소프트웨어의 구성요소(컴퍼넌트, 클래스, 모듈, 함수)는 확장에는 열려있고, 변경에는 닫혀있어야 하는 원칙.
> 3. 리스코프 치환의 원칙(Liskov Substitution): 자식 클래스(서브 타입)는 언제나 자신의 부모 클래스(기반 타입)를 대체한다는 원칙.
> 4. 의존성 역전의 원칙(Dependency Inversion Principle): 실제 사용 관계는 바뀌지 않으며, 추상을 매개로 메시지를 주고받음으로써 관계를 최대한 느슨하게 만드는 원칙.

### **5. 객체지향 방법론 종류**
> 1. OOSE(Object Oriented Software Engineering)  
> => 설명: 유스케이스에 의한 접근 방법으로 유스케이스를 모든 모델의 근간으로 활용  
> => 특징: 분석, 설계, 구현 단계로 구성, 기능적 요구사항 중심의 시스템
>
> 2. OMT(Object Modeling Technology)
> => 설명: 객체지향 분석, 시스템 설계, 오브젝트 설계 및 구현의 4단계로 구성.
>
> 3. 객체지향 모델링: 시스템의 정적 구조 표현
>
> 4. 동적 모델링: 객체의 제어 흐름/상호 반응 표현
>
> 5. 기능 모델링: 데이터 값의 변화과정 표현  
> => 특징: 복잡한 대형 프로젝트에 유용, 기업 업무의 모델링 편리 및 사용자와 의사소통 편리
>
> 6. Booch  
> => 설명: OOD(Object Oriented Design)으로 설계부분만 존재, 설계 문서화를 강조하여 다이어그램 중심으로 개발하는 방법론  
> => 특징: 분석과 설계 분리 불가능, 분석하는 데 이용된 객체 모델의 설계시 적용.

## **💉 의존성(Dependency)**
### **1. Dependency란?**
> * 코드에서 두 모듈 간의 연결.
> * 객체지향언어에서는 두 클래스 간의 관계라고도 말함.
> * 일반적으로 둘 중 하나가 다른 하나를 어떤 용도를 위해 사용함.

### **2. Dependency가 위험한 이유**
> * 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경이 이루어지기 때문에.
> * 테스트 가능한 어플을 만들 때 의존성이 있으면 유닛테스트 작성이 어려움.
>   * 유닛테스트의 목적 자체가 다른 모듈로부터 독립적으로 테스트하는 것을 요구하기 때문에.

### **3. DI가 필요한 이유**
> * Dependency가 위험한 이유를 해결하기 위해서
> * 'new'를 사용해 모듈 내에서 다른 모듈을 초기화하지 않으려면 객체 생성은 다른 곳에서 하고, 생성된 객체를 참고하면 됨.
> * 의존성 주입은 Inversion of Control 개념을 바탕으로 합니다.
> * 클래스는 다른 클래스를 인스턴스화해야 하지만, 구성 클래스에서 인스턴스를 가져와야 합니다.
> * Java 클래스가 new 연산자를 통해 다른 클래스의 인스턴스를 생성하면 해당 클래스와 독립적으로 테스트하고 사용할 수 없다.

### **4. 클래스 외부에서 종속성을 제공하면 생기는 이점**
> * 클래스를 재사용 할 가능성을 높이고, 다른 클래스와 독립적으로 클래스를 테스트 할 수 있습니다.
> * 비즈니스 로직의 특정 구현이 아닌 클래스를 생성하는데 매우 효과적.

### **5. 의존성 주입(Dependency Injection)을 어떻게 할건가?
> * Contructor Injection: 생성자 삽입
> * Field Injection: 멤버 변수 삽입(비공개 안됨)
> * Method Injection: 메소드 매게 변수 삽입

### **6. JSR330에 따른 종속성 주입 순서**
> 1. Contructor
> 2. Field
> 3. Method

